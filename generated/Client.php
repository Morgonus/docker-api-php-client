<?php

declare(strict_types=1);

/*
 * This file has been auto generated by Jane,
 *
 * Do no edit it directly.
 */

namespace Docker\API;

class Client extends \Jane\OpenApiRuntime\Client\Psr7HttplugClient
{
    /**
     * Returns a list of containers. For details on the format, see [the inspect endpoint](#operation/ContainerInspect).
     *
     * @param array $queryParameters {
     *
     *     @var bool $all Return all containers. By default, only running containers are shown
     *     @var int $limit return this number of most recently created containers, including non-running ones
     *     @var bool $size return the size of container as fields `SizeRw` and `SizeRootFs`
     *     @var string $filters Filters to process on the container list, encoded as JSON (a `map[string][]string`). For example, `{"status": ["paused"]}` will only return paused containers. Available filters:

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerListBadRequestException
     * @throws \Docker\API\Exception\ContainerListInternalServerErrorException
     *
     * @return \Docker\API\Model\ContainerSummaryItem[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerList($queryParameters), $fetch);
    }

    /**
     * @param \Docker\API\Model\ContainersCreatePostBody $body            Container to create
     * @param array                                      $queryParameters {
     *
     *     @var string $name Assign the specified name to the container. Must match `/?[a-zA-Z0-9_-]+`.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerCreateBadRequestException
     * @throws \Docker\API\Exception\ContainerCreateNotFoundException
     * @throws \Docker\API\Exception\ContainerCreateConflictException
     * @throws \Docker\API\Exception\ContainerCreateInternalServerErrorException
     *
     * @return \Docker\API\Model\ContainersCreatePostResponse201|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerCreate(\Docker\API\Model\ContainersCreatePostBody $body, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerCreate($body, $queryParameters), $fetch);
    }

    /**
     * Return low-level information about a container.
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var bool $size Return the size of container as fields `SizeRw` and `SizeRootFs`
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerInspectNotFoundException
     * @throws \Docker\API\Exception\ContainerInspectInternalServerErrorException
     *
     * @return \Docker\API\Model\ContainersIdJsonGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerInspect(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerInspect($id, $queryParameters), $fetch);
    }

    /**
     * On Unix systems, this is done by running the `ps` command. This endpoint is not supported on Windows.
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $ps_args The arguments to pass to `ps`. For example, `aux`
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerTopNotFoundException
     * @throws \Docker\API\Exception\ContainerTopInternalServerErrorException
     *
     * @return \Docker\API\Model\ContainersIdTopGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerTop(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerTop($id, $queryParameters), $fetch);
    }

    /**
     * Get `stdout` and `stderr` logs from a container.
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var bool $follow Return the logs as a stream.

     *     @var bool $stdout Return logs from `stdout`
     *     @var bool $stderr Return logs from `stderr`
     *     @var int $since Only return logs since this time, as a UNIX timestamp
     *     @var int $until Only return logs before this time, as a UNIX timestamp
     *     @var bool $timestamps Add timestamps to every log line
     *     @var string $tail Only return this number of log lines from the end of the logs. Specify as an integer or `all` to output all log lines.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerLogsNotFoundException
     * @throws \Docker\API\Exception\ContainerLogsInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerLogs(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerLogs($id, $queryParameters), $fetch);
    }

    /**
     * Returns which files in a container's filesystem have been added, deleted,.
     *
     * @param string $id    ID or name of the container
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerChangesNotFoundException
     * @throws \Docker\API\Exception\ContainerChangesInternalServerErrorException
     *
     * @return \Docker\API\Model\ContainersIdChangesGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerChanges(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerChanges($id), $fetch);
    }

    /**
     * Export the contents of a container as a tarball.
     *
     * @param string $id    ID or name of the container
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerExportNotFoundException
     * @throws \Docker\API\Exception\ContainerExportInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerExport(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerExport($id), $fetch);
    }

    /**
     * This endpoint returns a live stream of a container’s resource usage.

    The `precpu_stats` is the CPU statistic of the *previous* read, and is
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var bool $stream Stream the output. If false, the stats will be output once and then it will disconnect.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerStatsNotFoundException
     * @throws \Docker\API\Exception\ContainerStatsInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerStats(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerStats($id, $queryParameters), $fetch);
    }

    /**
     * Resize the TTY for a container. You must restart the container for the resize to take effect.
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var int $h Height of the tty session in characters
     *     @var int $w Width of the tty session in characters
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerResizeNotFoundException
     * @throws \Docker\API\Exception\ContainerResizeInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerResize(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerResize($id, $queryParameters), $fetch);
    }

    /**
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $detachKeys Override the key sequence for detaching a container. Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, `,` or `_`.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerStartNotFoundException
     * @throws \Docker\API\Exception\ContainerStartInternalServerErrorException
     *
     * @return \Docker\API\Model\ErrorResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerStart(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerStart($id, $queryParameters), $fetch);
    }

    /**
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var int $t Number of seconds to wait before killing the container
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerStopNotFoundException
     * @throws \Docker\API\Exception\ContainerStopInternalServerErrorException
     *
     * @return \Docker\API\Model\ErrorResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerStop(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerStop($id, $queryParameters), $fetch);
    }

    /**
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var int $t Number of seconds to wait before killing the container
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerRestartNotFoundException
     * @throws \Docker\API\Exception\ContainerRestartInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerRestart(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerRestart($id, $queryParameters), $fetch);
    }

    /**
     * Send a POSIX signal to a container, defaulting to killing to the container.
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $signal Signal to send to the container as an integer or string (e.g. `SIGINT`)
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerKillNotFoundException
     * @throws \Docker\API\Exception\ContainerKillConflictException
     * @throws \Docker\API\Exception\ContainerKillInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerKill(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerKill($id, $queryParameters), $fetch);
    }

    /**
     * Change various configuration options of a container without having to recreate it.
     *
     * @param string $id    ID or name of the container
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerUpdateNotFoundException
     * @throws \Docker\API\Exception\ContainerUpdateInternalServerErrorException
     *
     * @return \Docker\API\Model\ContainersIdUpdatePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerUpdate(string $id, \Docker\API\Model\ContainersIdUpdatePostBody $update, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerUpdate($id, $update), $fetch);
    }

    /**
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $name New name for the container
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerRenameNotFoundException
     * @throws \Docker\API\Exception\ContainerRenameConflictException
     * @throws \Docker\API\Exception\ContainerRenameInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerRename(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerRename($id, $queryParameters), $fetch);
    }

    /**
     * Use the cgroups freezer to suspend all processes in a container.
     *
     * @param string $id    ID or name of the container
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerPauseNotFoundException
     * @throws \Docker\API\Exception\ContainerPauseInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerPause(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerPause($id), $fetch);
    }

    /**
     * Resume a container which has been paused.
     *
     * @param string $id    ID or name of the container
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerUnpauseNotFoundException
     * @throws \Docker\API\Exception\ContainerUnpauseInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerUnpause(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerUnpause($id), $fetch);
    }

    /**
     * Attach to a container to read its output or send it input. You can attach to the same container multiple times and you can reattach to containers that have been detached.
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $detachKeys Override the key sequence for detaching a container.Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, `,` or `_`.
     *     @var bool $logs Replay previous logs from the container.

     *     @var bool $stream Stream attached streams from the time the request was made onwards
     *     @var bool $stdin Attach to `stdin`
     *     @var bool $stdout Attach to `stdout`
     *     @var bool $stderr Attach to `stderr`
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerAttachBadRequestException
     * @throws \Docker\API\Exception\ContainerAttachNotFoundException
     * @throws \Docker\API\Exception\ContainerAttachInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerAttach(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerAttach($id, $queryParameters), $fetch);
    }

    /**
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $detachKeys Override the key sequence for detaching a container.Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, `,`, or `_`.
     *     @var bool $logs Return logs
     *     @var bool $stream Return stream
     *     @var bool $stdin Attach to `stdin`
     *     @var bool $stdout Attach to `stdout`
     *     @var bool $stderr Attach to `stderr`
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerAttachWebsocketBadRequestException
     * @throws \Docker\API\Exception\ContainerAttachWebsocketNotFoundException
     * @throws \Docker\API\Exception\ContainerAttachWebsocketInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerAttachWebsocket(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerAttachWebsocket($id, $queryParameters), $fetch);
    }

    /**
     * Block until a container stops, then returns the exit code.
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $condition Wait until a container state reaches the given condition, either 'not-running' (default), 'next-exit', or 'removed'.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerWaitNotFoundException
     * @throws \Docker\API\Exception\ContainerWaitInternalServerErrorException
     *
     * @return \Docker\API\Model\ContainersIdWaitPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerWait(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerWait($id, $queryParameters), $fetch);
    }

    /**
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var bool $v remove the volumes associated with the container
     *     @var bool $force if the container is running, kill it before removing it
     *     @var bool $link Remove the specified link associated with the container.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerDeleteBadRequestException
     * @throws \Docker\API\Exception\ContainerDeleteNotFoundException
     * @throws \Docker\API\Exception\ContainerDeleteConflictException
     * @throws \Docker\API\Exception\ContainerDeleteInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerDelete(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerDelete($id, $queryParameters), $fetch);
    }

    /**
     * Get a tar archive of a resource in the filesystem of container id.
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $path Resource in the container’s filesystem to archive.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerArchiveBadRequestException
     * @throws \Docker\API\Exception\ContainerArchiveNotFoundException
     * @throws \Docker\API\Exception\ContainerArchiveInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerArchive(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerArchive($id, $queryParameters), $fetch);
    }

    /**
     * A response header `X-Docker-Container-Path-Stat` is return containing a base64 - encoded JSON object with some filesystem header information about the path.
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $path Resource in the container’s filesystem to archive.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerArchiveInfoBadRequestException
     * @throws \Docker\API\Exception\ContainerArchiveInfoNotFoundException
     * @throws \Docker\API\Exception\ContainerArchiveInfoInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerArchiveInfo(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerArchiveInfo($id, $queryParameters), $fetch);
    }

    /**
     * Upload a tar archive to be extracted to a path in the filesystem of container id.
     *
     * @param string $id              ID or name of the container
     * @param string $inputStream     the input stream must be a tar archive compressed with one of the following algorithms: identity (no compression), gzip, bzip2, xz
     * @param array  $queryParameters {
     *
     *     @var string $path path to a directory in the container to extract the archive’s contents into
     *     @var string $noOverwriteDirNonDir If “1”, “true”, or “True” then it will be an error if unpacking the given content would cause an existing directory to be replaced with a non-directory and vice versa.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\PutContainerArchiveBadRequestException
     * @throws \Docker\API\Exception\PutContainerArchiveForbiddenException
     * @throws \Docker\API\Exception\PutContainerArchiveNotFoundException
     * @throws \Docker\API\Exception\PutContainerArchiveInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function putContainerArchive(string $id, string $inputStream, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\PutContainerArchive($id, $inputStream, $queryParameters), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters Filters to process on the prune list, encoded as JSON (a `map[string][]string`).

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerPruneInternalServerErrorException
     *
     * @return \Docker\API\Model\ContainersPrunePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerPrune(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerPrune($queryParameters), $fetch);
    }

    /**
     * Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.
     *
     * @param array $queryParameters {
     *
     *     @var bool $all Show all images. Only images from a final layer (no children) are shown by default.
     *     @var string $filters A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters:

     *     @var bool $digests Show digest information as a `RepoDigests` field on each image.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ImageListInternalServerErrorException
     *
     * @return \Docker\API\Model\ImageSummary[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function imageList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ImageList($queryParameters), $fetch);
    }

    /**
     * Build an image from a tar archive with a `Dockerfile` in it.
     *
     * @param string|resource|\Psr\Http\Message\StreamInterface $inputStream     a tar archive compressed with one of the following algorithms: identity (no compression), gzip, bzip2, xz
     * @param array                                             $queryParameters {
     *
     *     @var string $dockerfile Path within the build context to the `Dockerfile`. This is ignored if `remote` is specified and points to an external `Dockerfile`.
     *     @var string $t A name and optional tag to apply to the image in the `name:tag` format. If you omit the tag the default `latest` value is assumed. You can provide several `t` parameters.
     *     @var string $extrahosts Extra hosts to add to /etc/hosts
     *     @var string $remote A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the file’s contents are placed into a file called `Dockerfile` and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the `dockerfile` parameter is also specified, there must be a file with the corresponding path inside the tarball.
     *     @var bool $q suppress verbose build output
     *     @var bool $nocache do not use the cache when building the image
     *     @var string $cachefrom JSON array of images used for build cache resolution
     *     @var string $pull attempt to pull the image even if an older image exists locally
     *     @var bool $rm remove intermediate containers after a successful build
     *     @var bool $forcerm always remove intermediate containers, even upon failure
     *     @var int $memory set memory limit for build
     *     @var int $memswap Total memory (memory + swap). Set as `-1` to disable swap.
     *     @var int $cpushares CPU shares (relative weight)
     *     @var string $cpusetcpus CPUs in which to allow execution (e.g., `0-3`, `0,1`).
     *     @var int $cpuperiod the length of a CPU period in microseconds
     *     @var int $cpuquota microseconds of CPU time that the container can get in a CPU period
     *     @var string $buildargs JSON map of string pairs for build-time variables. Users pass these values at build-time. Docker uses the buildargs as the environment context for commands run via the `Dockerfile` RUN instruction, or for variable expansion in other `Dockerfile` instructions. This is not meant for passing secret values.

     *     @var int $shmsize Size of `/dev/shm` in bytes. The size must be greater than 0. If omitted the system uses 64MB.
     *     @var bool $squash Squash the resulting images layers into a single layer. *(Experimental release only.)*
     *     @var string $labels arbitrary key/value labels to set on the image, as a JSON map of string pairs
     *     @var string $networkmode Sets the networking mode for the run commands during build. Supported standard values are: `bridge`, `host`, `none`, and `container:<name|id>`. Any other value is taken as a custom network's name to which this container should connect to.
     *     @var string $platform Platform in the format os[/arch[/variant]]
     *     @var string $target Target build stage
     * }
     *
     * @param array $headerParameters {
     *
     *     @var string $Content-type
     *     @var string $X-Registry-Config This is a base64-encoded JSON object with auth configurations for multiple registries that a build may refer to.

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ImageBuildBadRequestException
     * @throws \Docker\API\Exception\ImageBuildInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function imageBuild($inputStream, array $queryParameters = [], array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ImageBuild($inputStream, $queryParameters, $headerParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\BuildPruneInternalServerErrorException
     *
     * @return \Docker\API\Model\BuildPrunePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function buildPrune(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\BuildPrune(), $fetch);
    }

    /**
     * Create an image by either pulling it from a registry or importing it.
     *
     * @param string $inputImage      Image content if the value `-` has been specified in fromSrc query parameter
     * @param array  $queryParameters {
     *
     *     @var string $fromImage Name of the image to pull. The name may include a tag or digest. This parameter may only be used when pulling an image. The pull is cancelled if the HTTP connection is closed.
     *     @var string $fromSrc Source to import. The value may be a URL from which the image can be retrieved or `-` to read the image from the request body. This parameter may only be used when importing an image.
     *     @var string $repo Repository name given to an image when it is imported. The repo may include a tag. This parameter may only be used when importing an image.
     *     @var string $tag Tag or digest. If empty when pulling an image, this causes all tags for the given image to be pulled.
     *     @var string $platform Platform in the format os[/arch[/variant]]
     * }
     *
     * @param array $headerParameters {
     *
     *     @var string $X-Registry-Auth A base64-encoded auth configuration. [See the authentication section for details.](#section/Authentication)
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ImageCreateNotFoundException
     * @throws \Docker\API\Exception\ImageCreateInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function imageCreate(string $inputImage, array $queryParameters = [], array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ImageCreate($inputImage, $queryParameters, $headerParameters), $fetch);
    }

    /**
     * Return low-level information about an image.
     *
     * @param string $name  Image name or id
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ImageInspectNotFoundException
     * @throws \Docker\API\Exception\ImageInspectInternalServerErrorException
     *
     * @return \Docker\API\Model\Image|\Psr\Http\Message\ResponseInterface|null
     */
    public function imageInspect(string $name, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ImageInspect($name), $fetch);
    }

    /**
     * Return parent layers of an image.
     *
     * @param string $name  Image name or ID
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ImageHistoryNotFoundException
     * @throws \Docker\API\Exception\ImageHistoryInternalServerErrorException
     *
     * @return \Docker\API\Model\ImagesNameHistoryGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function imageHistory(string $name, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ImageHistory($name), $fetch);
    }

    /**
     * Push an image to a registry.
     *
     * @param string $name            image name or ID
     * @param array  $queryParameters {
     *
     *     @var string $tag The tag to associate with the image on the registry.
     * }
     *
     * @param array $headerParameters {
     *
     *     @var string $X-Registry-Auth A base64-encoded auth configuration. [See the authentication section for details.](#section/Authentication)
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ImagePushNotFoundException
     * @throws \Docker\API\Exception\ImagePushInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function imagePush(string $name, array $queryParameters = [], array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ImagePush($name, $queryParameters, $headerParameters), $fetch);
    }

    /**
     * Tag an image so that it becomes part of a repository.
     *
     * @param string $name            image name or ID to tag
     * @param array  $queryParameters {
     *
     *     @var string $repo The repository to tag in. For example, `someuser/someimage`.
     *     @var string $tag The name of the new tag.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ImageTagBadRequestException
     * @throws \Docker\API\Exception\ImageTagNotFoundException
     * @throws \Docker\API\Exception\ImageTagConflictException
     * @throws \Docker\API\Exception\ImageTagInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function imageTag(string $name, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ImageTag($name, $queryParameters), $fetch);
    }

    /**
     * Remove an image, along with any untagged parent images that were.
     *
     * @param string $name            Image name or ID
     * @param array  $queryParameters {
     *
     *     @var bool $force Remove the image even if it is being used by stopped containers or has other tags
     *     @var bool $noprune Do not delete untagged parent images
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ImageDeleteNotFoundException
     * @throws \Docker\API\Exception\ImageDeleteConflictException
     * @throws \Docker\API\Exception\ImageDeleteInternalServerErrorException
     *
     * @return \Docker\API\Model\ImageDeleteResponseItem[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function imageDelete(string $name, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ImageDelete($name, $queryParameters), $fetch);
    }

    /**
     * Search for an image on Docker Hub.
     *
     * @param array $queryParameters {
     *
     *     @var string $term Term to search
     *     @var int $limit Maximum number of results to return
     *     @var string $filters A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters:

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ImageSearchInternalServerErrorException
     *
     * @return \Docker\API\Model\ImagesSearchGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function imageSearch(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ImageSearch($queryParameters), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters Filters to process on the prune list, encoded as JSON (a `map[string][]string`). Available filters:
    - `dangling=<boolean>` When set to `true` (or `1`), prune only
      unused *and* untagged images. When set to `false`

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ImagePruneInternalServerErrorException
     *
     * @return \Docker\API\Model\ImagesPrunePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function imagePrune(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ImagePrune($queryParameters), $fetch);
    }

    /**
     * Validate credentials for a registry and, if available, get an identity token for accessing the registry without password.
     *
     * @param \Docker\API\Model\AuthConfig $authConfig Authentication to check
     * @param string                       $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SystemAuthInternalServerErrorException
     *
     * @return \Docker\API\Model\AuthPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function systemAuth(\Docker\API\Model\AuthConfig $authConfig, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SystemAuth($authConfig), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SystemInfoInternalServerErrorException
     *
     * @return \Docker\API\Model\SystemInfo|\Psr\Http\Message\ResponseInterface|null
     */
    public function systemInfo(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SystemInfo(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SystemVersionInternalServerErrorException
     *
     * @return \Docker\API\Model\VersionGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function systemVersion(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SystemVersion(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SystemPingInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function systemPing(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SystemPing(), $fetch);
    }

    /**
     * @param \Docker\API\Model\ContainerConfig $containerConfig The container configuration
     * @param array                             $queryParameters {
     *
     *     @var string $container The ID or name of the container to commit
     *     @var string $repo Repository name for the created image
     *     @var string $tag Tag name for the create image
     *     @var string $comment Commit message
     *     @var string $author Author of the image (e.g., `John Hannibal Smith <hannibal@a-team.com>`)
     *     @var bool $pause Whether to pause the container before committing
     *     @var string $changes `Dockerfile` instructions to apply while committing
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ImageCommitNotFoundException
     * @throws \Docker\API\Exception\ImageCommitInternalServerErrorException
     *
     * @return \Docker\API\Model\IdResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function imageCommit(\Docker\API\Model\ContainerConfig $containerConfig, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ImageCommit($containerConfig, $queryParameters), $fetch);
    }

    /**
     * Stream real-time events from the server.
     *
     * @param array $queryParameters {
     *
     *     @var string $since show events created since this timestamp then stream new events
     *     @var string $until show events created until this timestamp then stop streaming
     *     @var string $filters A JSON encoded value of filters (a `map[string][]string`) to process on the event list. Available filters:

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SystemEventsBadRequestException
     * @throws \Docker\API\Exception\SystemEventsInternalServerErrorException
     *
     * @return \Docker\API\Model\EventsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function systemEvents(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SystemEvents($queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SystemDataUsageInternalServerErrorException
     *
     * @return \Docker\API\Model\SystemDfGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function systemDataUsage(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SystemDataUsage(), $fetch);
    }

    /**
     * Get a tarball containing all images and metadata for a repository.
     *
     * @param string $name  Image name or ID
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ImageGetInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function imageGet(string $name, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ImageGet($name), $fetch);
    }

    /**
     * Get a tarball containing all images and metadata for several image repositories.
     *
     * @param array $queryParameters {
     *
     *     @var array $names Image names to filter by
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ImageGetAllInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function imageGetAll(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ImageGetAll($queryParameters), $fetch);
    }

    /**
     * Load a set of images and tags into a repository.
     *
     * @param string|resource|\Psr\Http\Message\StreamInterface $imagesTarball   Tar archive containing images
     * @param array                                             $queryParameters {
     *
     *     @var bool $quiet Suppress progress details during load.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ImageLoadInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function imageLoad($imagesTarball, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ImageLoad($imagesTarball, $queryParameters), $fetch);
    }

    /**
     * Run a command inside a running container.
     *
     * @param string                                     $id         ID or name of container
     * @param \Docker\API\Model\ContainersIdExecPostBody $execConfig Exec configuration
     * @param string                                     $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ContainerExecNotFoundException
     * @throws \Docker\API\Exception\ContainerExecConflictException
     * @throws \Docker\API\Exception\ContainerExecInternalServerErrorException
     *
     * @return \Docker\API\Model\IdResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerExec(string $id, \Docker\API\Model\ContainersIdExecPostBody $execConfig, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ContainerExec($id, $execConfig), $fetch);
    }

    /**
     * Starts a previously set up exec instance. If detach is true, this endpoint returns immediately after starting the command. Otherwise, it sets up an interactive session with the command.
     *
     * @param string $id    Exec instance ID
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ExecStartNotFoundException
     * @throws \Docker\API\Exception\ExecStartConflictException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function execStart(string $id, \Docker\API\Model\ExecIdStartPostBody $execStartConfig, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ExecStart($id, $execStartConfig), $fetch);
    }

    /**
     * Resize the TTY session used by an exec instance. This endpoint only works if `tty` was specified as part of creating and starting the exec instance.
     *
     * @param string $id              Exec instance ID
     * @param array  $queryParameters {
     *
     *     @var int $h Height of the TTY session in characters
     *     @var int $w Width of the TTY session in characters
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ExecResizeNotFoundException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function execResize(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ExecResize($id, $queryParameters), $fetch);
    }

    /**
     * Return low-level information about an exec instance.
     *
     * @param string $id    Exec instance ID
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ExecInspectNotFoundException
     * @throws \Docker\API\Exception\ExecInspectInternalServerErrorException
     *
     * @return \Docker\API\Model\ExecIdJsonGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function execInspect(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ExecInspect($id), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters JSON encoded value of the filters (a `map[string][]string`) to

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\VolumeListInternalServerErrorException
     *
     * @return \Docker\API\Model\VolumesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function volumeList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\VolumeList($queryParameters), $fetch);
    }

    /**
     * @param \Docker\API\Model\VolumesCreatePostBody $volumeConfig Volume configuration
     * @param string                                  $fetch        Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\VolumeCreateInternalServerErrorException
     *
     * @return \Docker\API\Model\Volume|\Psr\Http\Message\ResponseInterface|null
     */
    public function volumeCreate(\Docker\API\Model\VolumesCreatePostBody $volumeConfig, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\VolumeCreate($volumeConfig), $fetch);
    }

    /**
     * Instruct the driver to remove the volume.
     *
     * @param string $name            Volume name or ID
     * @param array  $queryParameters {
     *
     *     @var bool $force Force the removal of the volume
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\VolumeDeleteNotFoundException
     * @throws \Docker\API\Exception\VolumeDeleteConflictException
     * @throws \Docker\API\Exception\VolumeDeleteInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function volumeDelete(string $name, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\VolumeDelete($name, $queryParameters), $fetch);
    }

    /**
     * @param string $name  Volume name or ID
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\VolumeInspectNotFoundException
     * @throws \Docker\API\Exception\VolumeInspectInternalServerErrorException
     *
     * @return \Docker\API\Model\Volume|\Psr\Http\Message\ResponseInterface|null
     */
    public function volumeInspect(string $name, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\VolumeInspect($name), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters Filters to process on the prune list, encoded as JSON (a `map[string][]string`).

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\VolumePruneInternalServerErrorException
     *
     * @return \Docker\API\Model\VolumesPrunePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function volumePrune(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\VolumePrune($queryParameters), $fetch);
    }

    /**
     * Returns a list of networks. For details on the format, see [the network inspect endpoint](#operation/NetworkInspect).
     *
     * @param array $queryParameters {
     *
     *     @var string $filters JSON encoded value of the filters (a `map[string][]string`) to process on the networks list. Available filters:

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\NetworkListInternalServerErrorException
     *
     * @return \Docker\API\Model\Network[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function networkList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\NetworkList($queryParameters), $fetch);
    }

    /**
     * @param string $id    Network ID or name
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\NetworkDeleteForbiddenException
     * @throws \Docker\API\Exception\NetworkDeleteNotFoundException
     * @throws \Docker\API\Exception\NetworkDeleteInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function networkDelete(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\NetworkDelete($id), $fetch);
    }

    /**
     * @param string $id              Network ID or name
     * @param array  $queryParameters {
     *
     *     @var bool $verbose Detailed inspect output for troubleshooting
     *     @var string $scope Filter the network by scope (swarm, global, or local)
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\NetworkInspectNotFoundException
     * @throws \Docker\API\Exception\NetworkInspectInternalServerErrorException
     *
     * @return \Docker\API\Model\Network|\Psr\Http\Message\ResponseInterface|null
     */
    public function networkInspect(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\NetworkInspect($id, $queryParameters), $fetch);
    }

    /**
     * @param \Docker\API\Model\NetworksCreatePostBody $networkConfig Network configuration
     * @param string                                   $fetch         Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\NetworkCreateForbiddenException
     * @throws \Docker\API\Exception\NetworkCreateNotFoundException
     * @throws \Docker\API\Exception\NetworkCreateInternalServerErrorException
     *
     * @return \Docker\API\Model\NetworksCreatePostResponse201|\Psr\Http\Message\ResponseInterface|null
     */
    public function networkCreate(\Docker\API\Model\NetworksCreatePostBody $networkConfig, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\NetworkCreate($networkConfig), $fetch);
    }

    /**
     * @param string $id    Network ID or name
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\NetworkConnectForbiddenException
     * @throws \Docker\API\Exception\NetworkConnectNotFoundException
     * @throws \Docker\API\Exception\NetworkConnectInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function networkConnect(string $id, \Docker\API\Model\NetworksIdConnectPostBody $container, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\NetworkConnect($id, $container), $fetch);
    }

    /**
     * @param string $id    Network ID or name
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\NetworkDisconnectForbiddenException
     * @throws \Docker\API\Exception\NetworkDisconnectNotFoundException
     * @throws \Docker\API\Exception\NetworkDisconnectInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function networkDisconnect(string $id, \Docker\API\Model\NetworksIdDisconnectPostBody $container, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\NetworkDisconnect($id, $container), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters Filters to process on the prune list, encoded as JSON (a `map[string][]string`).

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\NetworkPruneInternalServerErrorException
     *
     * @return \Docker\API\Model\NetworksPrunePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function networkPrune(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\NetworkPrune($queryParameters), $fetch);
    }

    /**
     * Returns information about installed plugins.
     *
     * @param array $queryParameters {
     *
     *     @var string $filters A JSON encoded value of the filters (a `map[string][]string`) to process on the plugin list. Available filters:

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\PluginListInternalServerErrorException
     *
     * @return \Docker\API\Model\Plugin[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function pluginList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\PluginList($queryParameters), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $remote The name of the plugin. The `:latest` tag is optional, and is the default if omitted.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\GetPluginPrivilegesInternalServerErrorException
     *
     * @return \Docker\API\Model\PluginsPrivilegesGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getPluginPrivileges(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\GetPluginPrivileges($queryParameters), $fetch);
    }

    /**
     * Pulls and installs a plugin. After the plugin is installed, it can be enabled using the [`POST /plugins/{name}/enable` endpoint](#operation/PostPluginsEnable).
     *
     * @param array $queryParameters {
     *
     *     @var string $remote Remote reference for plugin to install.

     *     @var string $name Local name for the pulled plugin.

     * }
     *
     * @param array $headerParameters {
     *
     *     @var string $X-Registry-Auth A base64-encoded auth configuration to use when pulling a plugin from a registry. [See the authentication section for details.](#section/Authentication)
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\PluginPullInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function pluginPull(array $body, array $queryParameters = [], array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\PluginPull($body, $queryParameters, $headerParameters), $fetch);
    }

    /**
     * @param string $name  The name of the plugin. The `:latest` tag is optional, and is the default if omitted.
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\PluginInspectNotFoundException
     * @throws \Docker\API\Exception\PluginInspectInternalServerErrorException
     *
     * @return \Docker\API\Model\Plugin|\Psr\Http\Message\ResponseInterface|null
     */
    public function pluginInspect(string $name, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\PluginInspect($name), $fetch);
    }

    /**
     * @param string $name            The name of the plugin. The `:latest` tag is optional, and is the default if omitted.
     * @param array  $queryParameters {
     *
     *     @var bool $force Disable the plugin before removing. This may result in issues if the plugin is in use by a container.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\PluginDeleteNotFoundException
     * @throws \Docker\API\Exception\PluginDeleteInternalServerErrorException
     *
     * @return \Docker\API\Model\Plugin|\Psr\Http\Message\ResponseInterface|null
     */
    public function pluginDelete(string $name, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\PluginDelete($name, $queryParameters), $fetch);
    }

    /**
     * @param string $name            The name of the plugin. The `:latest` tag is optional, and is the default if omitted.
     * @param array  $queryParameters {
     *
     *     @var int $timeout Set the HTTP client timeout (in seconds)
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\PluginEnableNotFoundException
     * @throws \Docker\API\Exception\PluginEnableInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function pluginEnable(string $name, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\PluginEnable($name, $queryParameters), $fetch);
    }

    /**
     * @param string $name  The name of the plugin. The `:latest` tag is optional, and is the default if omitted.
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\PluginDisableNotFoundException
     * @throws \Docker\API\Exception\PluginDisableInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function pluginDisable(string $name, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\PluginDisable($name), $fetch);
    }

    /**
     * @param string $name            The name of the plugin. The `:latest` tag is optional, and is the default if omitted.
     * @param array  $queryParameters {
     *
     *     @var string $remote Remote reference to upgrade to.

     * }
     *
     * @param array $headerParameters {
     *
     *     @var string $X-Registry-Auth A base64-encoded auth configuration to use when pulling a plugin from a registry. [See the authentication section for details.](#section/Authentication)
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\PluginUpgradeNotFoundException
     * @throws \Docker\API\Exception\PluginUpgradeInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function pluginUpgrade(string $name, array $body, array $queryParameters = [], array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\PluginUpgrade($name, $body, $queryParameters, $headerParameters), $fetch);
    }

    /**
     * @param string|resource|\Psr\Http\Message\StreamInterface $tarContext      Path to tar containing plugin rootfs and manifest
     * @param array                                             $queryParameters {
     *
     *     @var string $name The name of the plugin. The `:latest` tag is optional, and is the default if omitted.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\PluginCreateInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function pluginCreate($tarContext, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\PluginCreate($tarContext, $queryParameters), $fetch);
    }

    /**
     * Push a plugin to the registry.
     *
     * @param string $name  The name of the plugin. The `:latest` tag is optional, and is the default if omitted.
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\PluginPushNotFoundException
     * @throws \Docker\API\Exception\PluginPushInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function pluginPush(string $name, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\PluginPush($name), $fetch);
    }

    /**
     * @param string $name  The name of the plugin. The `:latest` tag is optional, and is the default if omitted.
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\PluginSetNotFoundException
     * @throws \Docker\API\Exception\PluginSetInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function pluginSet(string $name, array $body, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\PluginSet($name, $body), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters Filters to process on the nodes list, encoded as JSON (a `map[string][]string`).

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\NodeListInternalServerErrorException
     * @throws \Docker\API\Exception\NodeListServiceUnavailableException
     *
     * @return \Docker\API\Model\Node[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function nodeList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\NodeList($queryParameters), $fetch);
    }

    /**
     * @param string $id              The ID or name of the node
     * @param array  $queryParameters {
     *
     *     @var bool $force Force remove a node from the swarm
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\NodeDeleteNotFoundException
     * @throws \Docker\API\Exception\NodeDeleteInternalServerErrorException
     * @throws \Docker\API\Exception\NodeDeleteServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function nodeDelete(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\NodeDelete($id, $queryParameters), $fetch);
    }

    /**
     * @param string $id    The ID or name of the node
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\NodeInspectNotFoundException
     * @throws \Docker\API\Exception\NodeInspectInternalServerErrorException
     * @throws \Docker\API\Exception\NodeInspectServiceUnavailableException
     *
     * @return \Docker\API\Model\Node|\Psr\Http\Message\ResponseInterface|null
     */
    public function nodeInspect(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\NodeInspect($id), $fetch);
    }

    /**
     * @param string $id              The ID of the node
     * @param array  $queryParameters {
     *
     *     @var int $version The version number of the node object being updated. This is required to avoid conflicting writes.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\NodeUpdateBadRequestException
     * @throws \Docker\API\Exception\NodeUpdateNotFoundException
     * @throws \Docker\API\Exception\NodeUpdateInternalServerErrorException
     * @throws \Docker\API\Exception\NodeUpdateServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function nodeUpdate(string $id, \Docker\API\Model\NodeSpec $body, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\NodeUpdate($id, $body, $queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SwarmInspectNotFoundException
     * @throws \Docker\API\Exception\SwarmInspectInternalServerErrorException
     * @throws \Docker\API\Exception\SwarmInspectServiceUnavailableException
     *
     * @return \Docker\API\Model\Swarm|\Psr\Http\Message\ResponseInterface|null
     */
    public function swarmInspect(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SwarmInspect(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SwarmInitBadRequestException
     * @throws \Docker\API\Exception\SwarmInitInternalServerErrorException
     * @throws \Docker\API\Exception\SwarmInitServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function swarmInit(\Docker\API\Model\SwarmInitPostBody $body, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SwarmInit($body), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SwarmJoinBadRequestException
     * @throws \Docker\API\Exception\SwarmJoinInternalServerErrorException
     * @throws \Docker\API\Exception\SwarmJoinServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function swarmJoin(\Docker\API\Model\SwarmJoinPostBody $body, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SwarmJoin($body), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var bool $force Force leave swarm, even if this is the last manager or that it will break the cluster.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SwarmLeaveInternalServerErrorException
     * @throws \Docker\API\Exception\SwarmLeaveServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function swarmLeave(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SwarmLeave($queryParameters), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var int $version The version number of the swarm object being updated. This is required to avoid conflicting writes.
     *     @var bool $rotateWorkerToken rotate the worker join token
     *     @var bool $rotateManagerToken rotate the manager join token
     *     @var bool $rotateManagerUnlockKey Rotate the manager unlock key.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SwarmUpdateBadRequestException
     * @throws \Docker\API\Exception\SwarmUpdateInternalServerErrorException
     * @throws \Docker\API\Exception\SwarmUpdateServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function swarmUpdate(\Docker\API\Model\SwarmSpec $body, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SwarmUpdate($body, $queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SwarmUnlockkeyInternalServerErrorException
     * @throws \Docker\API\Exception\SwarmUnlockkeyServiceUnavailableException
     *
     * @return \Docker\API\Model\SwarmUnlockkeyGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function swarmUnlockkey(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SwarmUnlockkey(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SwarmUnlockInternalServerErrorException
     * @throws \Docker\API\Exception\SwarmUnlockServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function swarmUnlock(\Docker\API\Model\SwarmUnlockPostBody $body, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SwarmUnlock($body), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters A JSON encoded value of the filters (a `map[string][]string`) to process on the services list. Available filters:

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ServiceListInternalServerErrorException
     * @throws \Docker\API\Exception\ServiceListServiceUnavailableException
     *
     * @return \Docker\API\Model\Service[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function serviceList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ServiceList($queryParameters), $fetch);
    }

    /**
     * @param array $headerParameters {
     *
     *     @var string $X-Registry-Auth A base64-encoded auth configuration for pulling from private registries. [See the authentication section for details.](#section/Authentication)
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ServiceCreateBadRequestException
     * @throws \Docker\API\Exception\ServiceCreateForbiddenException
     * @throws \Docker\API\Exception\ServiceCreateConflictException
     * @throws \Docker\API\Exception\ServiceCreateInternalServerErrorException
     * @throws \Docker\API\Exception\ServiceCreateServiceUnavailableException
     *
     * @return \Docker\API\Model\ServicesCreatePostResponse201|\Psr\Http\Message\ResponseInterface|null
     */
    public function serviceCreate(\Docker\API\Model\ServicesCreatePostBody $body, array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ServiceCreate($body, $headerParameters), $fetch);
    }

    /**
     * @param string $id    ID or name of service
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ServiceDeleteNotFoundException
     * @throws \Docker\API\Exception\ServiceDeleteInternalServerErrorException
     * @throws \Docker\API\Exception\ServiceDeleteServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function serviceDelete(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ServiceDelete($id), $fetch);
    }

    /**
     * @param string $id              ID or name of service
     * @param array  $queryParameters {
     *
     *     @var bool $insertDefaults Fill empty fields with default values.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ServiceInspectNotFoundException
     * @throws \Docker\API\Exception\ServiceInspectInternalServerErrorException
     * @throws \Docker\API\Exception\ServiceInspectServiceUnavailableException
     *
     * @return \Docker\API\Model\Service|\Psr\Http\Message\ResponseInterface|null
     */
    public function serviceInspect(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ServiceInspect($id, $queryParameters), $fetch);
    }

    /**
     * @param string $id              ID or name of service
     * @param array  $queryParameters {
     *
     *     @var int $version The version number of the service object being updated. This is required to avoid conflicting writes.
     *     @var string $registryAuthFrom If the X-Registry-Auth header is not specified, this parameter indicates where to find registry authorization credentials. The valid values are `spec` and `previous-spec`.
     *     @var string $rollback Set to this parameter to `previous` to cause a server-side rollback to the previous service spec. The supplied spec will be ignored in this case.
     * }
     *
     * @param array $headerParameters {
     *
     *     @var string $X-Registry-Auth A base64-encoded auth configuration for pulling from private registries. [See the authentication section for details.](#section/Authentication)
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ServiceUpdateBadRequestException
     * @throws \Docker\API\Exception\ServiceUpdateNotFoundException
     * @throws \Docker\API\Exception\ServiceUpdateInternalServerErrorException
     * @throws \Docker\API\Exception\ServiceUpdateServiceUnavailableException
     *
     * @return \Docker\API\Model\ServiceUpdateResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function serviceUpdate(string $id, \Docker\API\Model\ServicesIdUpdatePostBody $body, array $queryParameters = [], array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ServiceUpdate($id, $body, $queryParameters, $headerParameters), $fetch);
    }

    /**
     * Get `stdout` and `stderr` logs from a service.

     **Note**: This endpoint works only for services with the `json-file` or `journald` logging drivers.
     *
     * @param string $id              ID or name of the service
     * @param array  $queryParameters {
     *
     *     @var bool $details show service context and extra details provided to logs
     *     @var bool $follow Return the logs as a stream.

     *     @var bool $stdout Return logs from `stdout`
     *     @var bool $stderr Return logs from `stderr`
     *     @var int $since Only return logs since this time, as a UNIX timestamp
     *     @var bool $timestamps Add timestamps to every log line
     *     @var string $tail Only return this number of log lines from the end of the logs. Specify as an integer or `all` to output all log lines.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ServiceLogsNotFoundException
     * @throws \Docker\API\Exception\ServiceLogsInternalServerErrorException
     * @throws \Docker\API\Exception\ServiceLogsServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function serviceLogs(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ServiceLogs($id, $queryParameters), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters A JSON encoded value of the filters (a `map[string][]string`) to process on the tasks list. Available filters:

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\TaskListInternalServerErrorException
     * @throws \Docker\API\Exception\TaskListServiceUnavailableException
     *
     * @return \Docker\API\Model\Task[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function taskList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\TaskList($queryParameters), $fetch);
    }

    /**
     * @param string $id    ID of the task
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\TaskInspectNotFoundException
     * @throws \Docker\API\Exception\TaskInspectInternalServerErrorException
     * @throws \Docker\API\Exception\TaskInspectServiceUnavailableException
     *
     * @return \Docker\API\Model\Task|\Psr\Http\Message\ResponseInterface|null
     */
    public function taskInspect(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\TaskInspect($id), $fetch);
    }

    /**
     * Get `stdout` and `stderr` logs from a task.

     **Note**: This endpoint works only for services with the `json-file` or `journald` logging drivers.
     *
     * @param string $id              ID of the task
     * @param array  $queryParameters {
     *
     *     @var bool $details show task context and extra details provided to logs
     *     @var bool $follow Return the logs as a stream.

     *     @var bool $stdout Return logs from `stdout`
     *     @var bool $stderr Return logs from `stderr`
     *     @var int $since Only return logs since this time, as a UNIX timestamp
     *     @var bool $timestamps Add timestamps to every log line
     *     @var string $tail Only return this number of log lines from the end of the logs. Specify as an integer or `all` to output all log lines.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\TaskLogsNotFoundException
     * @throws \Docker\API\Exception\TaskLogsInternalServerErrorException
     * @throws \Docker\API\Exception\TaskLogsServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function taskLogs(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\TaskLogs($id, $queryParameters), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters A JSON encoded value of the filters (a `map[string][]string`) to process on the secrets list. Available filters:

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SecretListInternalServerErrorException
     * @throws \Docker\API\Exception\SecretListServiceUnavailableException
     *
     * @return \Docker\API\Model\Secret[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function secretList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SecretList($queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SecretCreateConflictException
     * @throws \Docker\API\Exception\SecretCreateInternalServerErrorException
     * @throws \Docker\API\Exception\SecretCreateServiceUnavailableException
     *
     * @return \Docker\API\Model\IdResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function secretCreate(\Docker\API\Model\SecretsCreatePostBody $body, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SecretCreate($body), $fetch);
    }

    /**
     * @param string $id    ID of the secret
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SecretDeleteNotFoundException
     * @throws \Docker\API\Exception\SecretDeleteInternalServerErrorException
     * @throws \Docker\API\Exception\SecretDeleteServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function secretDelete(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SecretDelete($id), $fetch);
    }

    /**
     * @param string $id    ID of the secret
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SecretInspectNotFoundException
     * @throws \Docker\API\Exception\SecretInspectInternalServerErrorException
     * @throws \Docker\API\Exception\SecretInspectServiceUnavailableException
     *
     * @return \Docker\API\Model\Secret|\Psr\Http\Message\ResponseInterface|null
     */
    public function secretInspect(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SecretInspect($id), $fetch);
    }

    /**
     * @param string                       $id              The ID or name of the secret
     * @param \Docker\API\Model\SecretSpec $body            The spec of the secret to update. Currently, only the Labels field can be updated. All other fields must remain unchanged from the [SecretInspect endpoint](#operation/SecretInspect) response values.
     * @param array                        $queryParameters {
     *
     *     @var int $version The version number of the secret object being updated. This is required to avoid conflicting writes.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SecretUpdateBadRequestException
     * @throws \Docker\API\Exception\SecretUpdateNotFoundException
     * @throws \Docker\API\Exception\SecretUpdateInternalServerErrorException
     * @throws \Docker\API\Exception\SecretUpdateServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function secretUpdate(string $id, \Docker\API\Model\SecretSpec $body, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\SecretUpdate($id, $body, $queryParameters), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters A JSON encoded value of the filters (a `map[string][]string`) to process on the configs list. Available filters:

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ConfigListInternalServerErrorException
     * @throws \Docker\API\Exception\ConfigListServiceUnavailableException
     *
     * @return \Docker\API\Model\Config[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function configList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ConfigList($queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ConfigCreateConflictException
     * @throws \Docker\API\Exception\ConfigCreateInternalServerErrorException
     * @throws \Docker\API\Exception\ConfigCreateServiceUnavailableException
     *
     * @return \Docker\API\Model\IdResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function configCreate(\Docker\API\Model\ConfigsCreatePostBody $body, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ConfigCreate($body), $fetch);
    }

    /**
     * @param string $id    ID of the config
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ConfigDeleteNotFoundException
     * @throws \Docker\API\Exception\ConfigDeleteInternalServerErrorException
     * @throws \Docker\API\Exception\ConfigDeleteServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function configDelete(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ConfigDelete($id), $fetch);
    }

    /**
     * @param string $id    ID of the config
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ConfigInspectNotFoundException
     * @throws \Docker\API\Exception\ConfigInspectInternalServerErrorException
     * @throws \Docker\API\Exception\ConfigInspectServiceUnavailableException
     *
     * @return \Docker\API\Model\Config|\Psr\Http\Message\ResponseInterface|null
     */
    public function configInspect(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ConfigInspect($id), $fetch);
    }

    /**
     * @param string                       $id              The ID or name of the config
     * @param \Docker\API\Model\ConfigSpec $body            The spec of the config to update. Currently, only the Labels field can be updated. All other fields must remain unchanged from the [ConfigInspect endpoint](#operation/ConfigInspect) response values.
     * @param array                        $queryParameters {
     *
     *     @var int $version The version number of the config object being updated. This is required to avoid conflicting writes.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\ConfigUpdateBadRequestException
     * @throws \Docker\API\Exception\ConfigUpdateNotFoundException
     * @throws \Docker\API\Exception\ConfigUpdateInternalServerErrorException
     * @throws \Docker\API\Exception\ConfigUpdateServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function configUpdate(string $id, \Docker\API\Model\ConfigSpec $body, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\ConfigUpdate($id, $body, $queryParameters), $fetch);
    }

    /**
     * Return image digest and platform information by contacting the registry.
     *
     * @param string $name  Image name or id
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\DistributionInspectUnauthorizedException
     * @throws \Docker\API\Exception\DistributionInspectInternalServerErrorException
     *
     * @return \Docker\API\Model\DistributionNameJsonGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function distributionInspect(string $name, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\DistributionInspect($name), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\API\Exception\SessionBadRequestException
     * @throws \Docker\API\Exception\SessionInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function session(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executePsr7Endpoint(new \Docker\API\Endpoint\Session(), $fetch);
    }

    public static function create($httpClient = null)
    {
        if (null === $httpClient) {
            $httpClient = \Http\Discovery\HttpClientDiscovery::find();
            $plugins = [];
            $uri = \Http\Discovery\UriFactoryDiscovery::find()->createUri('v1.38');
            $plugins[] = new \Http\Client\Common\Plugin\AddPathPlugin($uri);
            $httpClient = new \Http\Client\Common\PluginClient($httpClient, $plugins);
        }
        $messageFactory = \Http\Discovery\MessageFactoryDiscovery::find();
        $streamFactory = \Http\Discovery\StreamFactoryDiscovery::find();
        $serializer = new \Symfony\Component\Serializer\Serializer(\Docker\API\Normalizer\NormalizerFactory::create(), [new \Symfony\Component\Serializer\Encoder\JsonEncoder(new \Symfony\Component\Serializer\Encoder\JsonEncode(), new \Symfony\Component\Serializer\Encoder\JsonDecode())]);

        return new static($httpClient, $messageFactory, $serializer, $streamFactory);
    }
}
